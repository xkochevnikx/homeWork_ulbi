import { useEffect, useRef } from "react";

export const useObserver = (
  lastElementRef,
  canLoad,
  isPostLoading,
  callback
) => {
  const observerRef = useRef();

  useEffect(() => {
    //? это функция коллбек которая должна отрабатывать на определённое событие в параметрах у неё объекты и функция каких то изменений которые можно с этими объектами проводить
    if (isPostLoading) return;
    if (observerRef.current) observerRef.current.disconnect();
    const callbackObs = function (entries, observer) {
      //? условие что функция отрабатывает только когда отслеживаемый элемент в зоне видимости и если номер текущей страницы меньше общего колличества страниц
      if (entries[0].isIntersecting && canLoad) {
        callback();
      }
    };
    //? для того чтобы у нас был доступ к функции внутри компонента сохраняем ее в референс что бы не терять данные от рендера к рендеру и соответсвенно новый IntersectionObserver помещаем в поле current этого референса. Вызываем эту функцию слежения а ниже передаём в неё из useRef сохранённый объект с полем current значением которого является дом элемент это див за которым следим
    observerRef.current = new IntersectionObserver(callbackObs);
    observerRef.current.observe(lastElementRef.current);
    //? callback при пустом массиве зависимости отрабатывает однократно при первом рендере и получается что он замыкает в себе page как единицу. что бы это исправить мы в зависимость пишем что когда у нас новый рендер мы пересоздаём observer и получается перезаписываем новое состояние page за счёт чего подгружается новая порция постов
  }, [isPostLoading]);
  //? вообщем как происходит работа этого обсёрвера - при первой отрисовке сначала инициализируются стейты потом useFetching возвращает первую порцию данных и отрисовывает их. пока запрос на получение данных не был получен обсёрвер не запускается. как только отрисовка случилась он видит изменения в isPostLoading это false это индикатор того что ответ получен и отрисован. Тогда начинает отрабатывать это useEffect если он видит что запрос не закончен он не пускает код ниже и если он видит что в референсе обсёрвера уже лежит что то в поле current нам нужно это слежение отсановить и дальше заново перезаписать всю функцию слежения. так же занаво из стейта взять обновлённое значение page. и далее уже на отрисованноые первые посты внизу повестить слежение на компонент дом дерева. когда мы к нему приблизились обсёрвер срабатывает и вызывает коллбэк который перезапускает рендер - происходит новый запрос - прилетают новые данные и записываются в хвост стейта с постами обсёрвер видит изменения в isPostLoading и проводит проверку если в референсе слежения есть запись он отсанавливает прошлое слежение - меняет номер текщей страницы и занаво создаёт новое слежение
};
